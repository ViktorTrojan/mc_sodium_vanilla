# CLAUDE.md

This file contains frequently-needed project rules embedded for quick reference. These rules are copied verbatim from `.ai/project/rules/` to minimize tool calls during common tasks.

**Files embedded in this document:**
- `read_only_rules.md` - Critical rules about read-only files
- `project_structure.md` - Project organization and structure
- `typescript_coding_style.md` - TypeScript coding standards
- `project_commands.md` - Common project commands
- `naming_conventions_rules.md` - Naming standards
- `typescript_testing_style.md` - Testing conventions and patterns
- `bun_runtime_rules.md` - Bun runtime configuration and usage
- `project_state_management.md` - Rules for keeping project documentation current

---

## üìÑ Source: `.ai/project/rules/read_only_rules.md`

# Read-Only Rules

Files and folders that AI agents should treat as read-only. These files should NOT be modified unless the user explicitly confirms with human input.

## Rarely Modified Files/Folders

These files and folders are rarely modified because they are already correctly configured and serve as standards for the project. They CAN be modified by explicitly asking the human for confirmation first.

```ignore
# Project configuration
modpack_creator/package.json
modpack_creator/tsconfig.json
modpack_creator/biome.json
docker-compose.yml
Dockerfile
.packwizignore

# Modpack configuration
pack.toml
index.toml

# Environment templates
modpack_creator/.env.example

# AI configuration
.ai/
.claude/

# GitHub workflows
.github/
```

**Rule:** Can be read freely. If modification seems necessary, MUST ask user for explicit confirmation before making changes.

## Special Cases

### pack.toml and index.toml
- `pack.toml`: Main packwiz configuration - only modify if changing modpack version or Minecraft version
- `index.toml`: Auto-generated by packwiz - rarely needs manual modification

### modpack_creator/package.json
- Contains scripts, dependencies, and project metadata
- Scripts define available commands - changes here affect the development workflow
- Dependencies should only be added when truly necessary

### Biome and TypeScript configs
- `modpack_creator/biome.json`: Defines linting, formatting, and code style rules
- `modpack_creator/tsconfig.json`: TypeScript compiler configuration
- Changes to these affect the entire codebase's style and type checking

## Never Modify Files/Folders

These files are auto-generated by tools and should NEVER be manually edited:

```ignore
# Lock files
modpack_creator/bun.lock

# TypeScript build info
*.tsbuildinfo
```

---

## üìÑ Source: `.ai/project/rules/project_structure.md`

# Project Structure

This document describes the structure of the Sodium Vanilla modpack project.

## Root Directory Structure

```
.ai/                  # AI assistant configuration and rules
.claude/              # Claude Code specific configuration
.github/              # GitHub Actions and workflows
docs/                 # Project documentation
modpack_creator/      # TypeScript/Bun tooling for modpack automation
mods/                 # Minecraft mod files (.toml files managed by packwiz)
resourcepacks/        # Minecraft resource packs
scripts/              # Shell scripts and utilities
docker-compose.yml    # Docker configuration for development
Dockerfile            # Docker image definition
index.toml            # Packwiz mod index
pack.toml             # Packwiz modpack configuration
.packwizignore        # Files to ignore for packwiz
README.md             # Project documentation
```

## Project Type

This is a **Minecraft modpack project** using:
- **packwiz**: For managing Minecraft mods and versions
- **Bun + TypeScript**: For automation tooling in the `modpack_creator/` directory

This is **NOT a monorepo**. The `modpack_creator/` directory contains a standalone tool for managing the modpack.

## modpack_creator/ Structure

The tooling directory follows this structure:

```
modpack_creator/
‚îú‚îÄ‚îÄ src/                  # Source code
‚îÇ   ‚îú‚îÄ‚îÄ index.ts          # Main entry point
‚îÇ   ‚îú‚îÄ‚îÄ auto_update.ts    # Auto-update script
‚îÇ   ‚îú‚îÄ‚îÄ mod_list.ts       # Mod list management
‚îÇ   ‚îú‚îÄ‚îÄ install_mods.ts   # Mod installation logic
‚îÇ   ‚îú‚îÄ‚îÄ git_tag_manager.ts # Git tag management
‚îÇ   ‚îú‚îÄ‚îÄ update_detector.ts # Update detection logic
‚îÇ   ‚îú‚îÄ‚îÄ version_discovery.ts # Version discovery
‚îÇ   ‚îú‚îÄ‚îÄ fetch_with_retry.ts # HTTP retry utility
‚îÇ   ‚îî‚îÄ‚îÄ types.ts          # TypeScript type definitions
‚îú‚îÄ‚îÄ test/                 # Test files (ending with `.test.ts`)
‚îÇ   ‚îú‚îÄ‚îÄ git_tag_manager.test.ts
‚îÇ   ‚îú‚îÄ‚îÄ update_detector.test.ts
‚îÇ   ‚îî‚îÄ‚îÄ version_discovery.test.ts
‚îú‚îÄ‚îÄ .env                  # Environment variables (gitignored)
‚îú‚îÄ‚îÄ .env.example          # Example environment variables (committed)
‚îú‚îÄ‚îÄ package.json          # Package configuration and scripts
‚îú‚îÄ‚îÄ biome.json            # Biome configuration for linting/formatting
‚îú‚îÄ‚îÄ tsconfig.json         # TypeScript configuration
‚îî‚îÄ‚îÄ README.md             # Tool documentation
```

## Key Files

### Modpack Configuration
- `pack.toml`: Main packwiz configuration defining modpack name, version, and Minecraft/Fabric versions
- `index.toml`: Index of all installed mods (auto-generated by packwiz)
- `mods/*.toml`: Individual mod configuration files managed by packwiz

### Tooling
- `modpack_creator/src/index.ts`: Main script that processes and installs mods
- `modpack_creator/src/auto_update.ts`: Automated update checker for mods
- `modpack_creator/src/mod_list.ts`: Manages the list of mods to install

## Modpack Variants

The project supports two modpack variants:
- **safe**: Only includes mods safe for multiplayer servers
- **full**: Includes all mods (may cause issues on some servers)

These are controlled by the `--safe` and `--full` flags when running the modpack creator tool.

---

## üìÑ Source: `.ai/project/rules/typescript_coding_style.md`

# TypeScript Coding Style

## Code Structure

- **Code Organization**: Prefer separating code into multiple functions and files to improve readability. Function and filenames should be descriptive so their purpose is clear.
- **File Granularity**: Each file should ideally focus on a single responsibility or a cohesive set of related functionalities. Avoid creating overly large or monolithic files.
- **Semicolons**: Do not use semicolons (configured in biome.json as "asNeeded").
- **Type Safety**: Avoid using `as any`. All code should remain type-safe. Use `unknown` with type guards when needed.

## Naming Conventions

- **Filenames, function names, variable names, object properties**: Use `snake_case`
- **Class names, interfaces, type aliases**: Use `PascalCase`
- **Enum values**: Use lowercase `snake_case`
- **Private class members**: Prefix with underscore `_my_private_property`

## Function Definitions

Use `function name()` instead of `const name = () =>`:

```typescript
// ‚úÖ CORRECT
function my_function(param: string): number {
  return param.length
}

export async function fetch_data(id: string): Promise<Data> {
  // ...
}

// ‚ùå INCORRECT
const my_function = (param: string): number => {
  return param.length
}
```

### Function Parameters

- **Type Annotations**: All parameters must have explicit type annotations
- **Named Parameters**: Use named parameters when a function has more than 3 parameters
- **Parameter Types**: Never inline complex object types; always define an interface or type alias

```typescript
// ‚úÖ CORRECT: Many parameters using interface
interface CreateUserParams {
  name: string
  email: string
  age: number
  address: string
}

function create_user(params: CreateUserParams): User {
  // ...
}

// ‚ùå INCORRECT: Inlined object type
function create_user(params: { name: string; email: string }): User {
  // ...
}
```

## Docstrings

Use JSDoc comments for public functions and classes. Focus on *why* a function/class exists and its purpose, rather than *what* it does (which should be clear from its name).

```typescript
/**
 * Performs an HTTP fetch with exponential backoff retry logic.
 *
 * Automatically retries on network errors and HTTP 429 (rate limit) responses.
 * Uses exponential backoff to increase delay between retries.
 */
async function fetch_with_retry(url: string, max_retries = 5): Promise<Response> {
  // ...
}

/**
 * Detects if any mods have available updates by comparing installed versions
 * with the latest versions from Modrinth API.
 *
 * @param installed_mods - Array of currently installed mod information
 */
function detect_updates(installed_mods: InstalledMod[]): Promise<UpdateInfo[]> {
  // ...
}
```

**When to use:**
- Always: Public functions, classes, complex algorithms
- Optional: Simple utility functions with self-explanatory names

## Error Handling

This project uses standard try/catch error handling with thrown exceptions.

```typescript
async function fetch_data(url: string): Promise<Data> {
  try {
    const response = await fetch(url)

    if (!response.ok) {
      throw new Error(`Failed to fetch: ${response.statusText}`)
    }

    return await response.json()
  } catch (error) {
    console.error("Fetch error:", error)
    throw error
  }
}
```

For retry logic and network operations, see [fetch_with_retry.ts](modpack_creator/src/fetch_with_retry.ts) which implements exponential backoff.

---

## üìÑ Source: `.ai/project/rules/project_commands.md`

# Project Commands

This project uses Bun for the TypeScript tooling in the `modpack_creator/` directory.

## Common Scripts

The following `bun run` scripts are available in `modpack_creator/package.json`:

### Development
- `bun run dev`: Runs the modpack creator tool (processes and installs mods)
- `bun run dev_full`: Runs the tool with `--full` flag (creates full modpack) and `--no-upload`
- `bun run dev_safe`: Runs the tool with `--safe` flag (creates safe modpack) and `--no-upload`
- `bun run auto-update`: Runs the auto-update script to check for mod updates

### Building
- `bun run build`: Builds the project for production with Bun bundler
- `bun run clean`: Deletes `node_modules` and `dist` folders

### Testing
- `bun run test`: Runs all tests using Bun's test runner
- `bun run test_coverage`: Runs tests with coverage reporting

### Code Quality
- `bun run check_all`: Runs type checking and fixes all linting/formatting issues (runs `check_fix` and `typecheck`)
- `bun run check_and_test`: Does all checks and runs tests with coverage. **You should mostly use this script.**
- `bun run typecheck`: Runs TypeScript type checking without emitting files
- `bun run check`: Checks code with Biome (linting and formatting)
- `bun run check_fix`: Fixes linting and formatting issues automatically
- `bun run format`: Formats code with Biome
- `bun run lint`: Lints code with Biome

### Versioning
- `bun run changeset`: Creates a new changeset for version management
- `bun run changeset_version`: Applies changesets and updates versions

## Running Commands

All commands should be run from the `modpack_creator/` directory:

```bash
cd modpack_creator
bun run check_and_test
```

Or from the project root:

```bash
cd modpack_creator && bun run check_and_test
```

---

## üìÑ Source: `.ai/project/rules/naming_conventions_rules.md`

# Naming Conventions

## File and Folder Naming

All files and folders MUST follow snake_case naming:

- **Use snake_case**: `user_profile.ts`, `mod_list.ts`, `git_tag_manager.ts`
- **Never use kebab-case**: ~~`user-profile.ts`~~, ~~`mod-list.ts`~~
- **Never use hyphens (-)**: The hyphen symbol is not allowed in file or folder names

## File Extensions

All files MUST have an appropriate extension:

- TypeScript: `.ts`
- TypeScript React: `.tsx`
- JavaScript: `.js`
- JSON: `.json`
- Markdown: `.md`
- TOML: `.toml`
- etc.

## Examples

### Correct
- `git_tag_manager.ts`
- `auto_update.ts`
- `fetch_with_retry.test.ts`
- `modpack_creator/`

### Incorrect
- ~~`git-tag-manager.ts`~~ (uses hyphens)
- ~~`autoUpdate.ts`~~ (uses camelCase for file name)
- ~~`GitTagManager.ts`~~ (uses PascalCase)
- ~~`config`~~ (missing extension)
- ~~`mod-list/`~~ (folder uses hyphens)

---

## üìÑ Source: `.ai/project/rules/typescript_testing_style.md`

# TypeScript Testing Style

Use Bun's built-in test runner. Test files use `snake_case` and end with `.test.ts`.

```typescript
import { describe, it, expect } from "bun:test"
```

## File Structure

Group related tests using `describe` blocks. Each `describe` block should test a specific function or feature.

```typescript
// ‚úÖ CORRECT - Multiple describe blocks grouping related tests
describe("parse_tag", () => {
  it("should parse valid tag with major.minor MC version", () => {})
  it("should return null for invalid tag formats", () => {})
})

describe("increment_version", () => {
  it("should increment patch version", () => {})
  it("should handle double-digit patch versions", () => {})
})
```

## Naming

- **describe block**: Name of the module/function being tested
- **it statements**: Clear sentences starting with "should"

```typescript
describe("compare_states", () => {
  it("should return false for identical states", () => {})
  it("should return true when successful mods differ", () => {})
})
```

## Test Approach

This project uses **unit tests without mocking**. Tests focus on pure functions with predictable inputs and outputs.

```typescript
import { describe, expect, it } from "bun:test"
import { increment_version, parse_tag } from "../src/git_tag_manager"

describe("parse_tag", () => {
  it("should parse valid tag with major.minor MC version", () => {
    expect(parse_tag("1.14_0.1.0")).toEqual({
      mc_version: "1.14",
      modpack_version: "0.1.0"
    })
  })

  it("should return null for invalid tag formats", () => {
    expect(parse_tag("invalid")).toBeNull()
    expect(parse_tag("1.14")).toBeNull()
  })
})

describe("increment_version", () => {
  it("should increment patch version", () => {
    expect(increment_version("0.1.0")).toBe("0.1.1")
    expect(increment_version("0.1.5")).toBe("0.1.6")
  })
})
```

## Common Assertions

```typescript
// Equality
expect(value).toBe(expected)
expect(object).toEqual(expected_object)

// Null checks
expect(value).toBeNull()
expect(value).not.toBeNull()

// Boolean checks
expect(result).toBe(true)
expect(result).toBe(false)

// Type checks
expect(value).toBeInstanceOf(Array)
```

## Complete Example

```typescript
import { describe, expect, it } from "bun:test"
import type { ModInstallationState } from "../src/types"
import { compare_states } from "../src/update_detector"

describe("compare_states", () => {
  it("should return false for identical states", () => {
    const state: ModInstallationState = {
      successful: [
        { method: "modrinth", identifier: "sodium", category: "optimization" },
        { method: "modrinth", identifier: "lithium", category: "optimization" }
      ],
      failed: [],
      alternative_installed: []
    }

    expect(compare_states(state, state)).toBe(false)
  })

  it("should return true when successful mods differ", () => {
    const old_state: ModInstallationState = {
      successful: [{ method: "modrinth", identifier: "sodium", category: "optimization" }],
      failed: [],
      alternative_installed: []
    }

    const new_state: ModInstallationState = {
      successful: [
        { method: "modrinth", identifier: "sodium", category: "optimization" },
        { method: "modrinth", identifier: "lithium", category: "optimization" }
      ],
      failed: [],
      alternative_installed: []
    }

    expect(compare_states(old_state, new_state)).toBe(true)
  })
})
```

## Best Practices

- One assertion concept per test
- Descriptive test names using "should"
- Test pure functions with clear inputs and outputs
- Avoid testing implementation details
- Group related tests in describe blocks

---

## üìÑ Source: `.ai/project/rules/bun_runtime_rules.md`

# Bun Runtime Rules

This project uses Bun as the runtime for the TypeScript tooling in `modpack_creator/`. Prefer Bun's built-in APIs over third-party packages when possible.

## Built-in APIs

- `Bun.serve()` - HTTP server with WebSocket support. Don't use `express`.
- `bun:sqlite` - SQLite database. Don't use `better-sqlite3`.
- `Bun.sql` - Postgres client. Don't use `pg` or `postgres.js`.
- `Bun.redis` - Redis client. Don't use `ioredis`.
- `WebSocket` - Built-in WebSocket. Don't use `ws` package.
- `Bun.file()` and `Bun.write()` - File I/O. Prefer over `node:fs` readFile/writeFile.
- `Bun.$` - Shell commands. Don't use `execa`.

## Environment Variables

Bun automatically loads `.env` files. **NEVER** use the `dotenv` package.

---

## üìÑ Source: `.ai/global/rules/project_state_management.md`

# Project State Management

This rule defines how AI agents should maintain and update project-specific information in the `.ai/project/` directory.

## Core Principle

When an AI agent makes changes to the project that affect documentation, configuration, or established patterns, it MUST update the corresponding files in `.ai/project/` to keep information current and accurate.

## When to Update Project Files

Update `.ai/project/` files when you:

- **Modify project structure**: Add/remove packages, apps, or tools
- **Change conventions**: Update naming patterns, coding styles, or practices
- **Add new scripts**: Introduce new commands in package.json
- **Update tooling**: Modify configuration files (biome.json, tsconfig.json, etc.)
- **Establish new patterns**: Create reusable patterns that should be documented
- **Change dependencies**: Add major libraries that affect coding practices

## What to Update

### `.ai/project/rules/`

Update rule files when project practices change:

- **project_structure.md**: When adding/removing packages, apps, or changing directory layout
- **monorepo_commands.md**: When adding new scripts or changing build commands
- **typescript_coding_style.md**: When adopting new coding patterns specific to this project
- **naming_conventions_rules.md**: When project-specific naming patterns are established

### `.ai/project/workflows/`

Create or update workflow files when:

- New multi-step processes become standardized
- Project-specific automation is added
- Deployment or build processes change

## How to Update

**After making changes:**

1. Identify which project files are affected by your changes
2. Update the relevant files in `.ai/project/` to reflect the new state
3. Ensure changes are specific and accurate
4. Verify consistency across related files
5. If rule files in `.ai/project/rules/` were updated, run the `claude_md_update_workflow.md` workflow to regenerate `CLAUDE.md`

**Example:**

```markdown
If you add a new script "bun run deploy" to package.json:
‚Üí Update .ai/project/rules/monorepo_commands.md to document the new command
‚Üí Run claude_md_update_workflow.md to update CLAUDE.md
```

## Do NOT Update

**Never modify:**
- Auto-generated files (CHANGELOG.md)
- Files in `.ai/global/` (those are generic templates)
- Files unless changes are confirmed and committed

## Verification

Before completing a task, verify:

- All affected `.ai/project/` files have been updated
- Documentation accurately reflects the current state
- No contradictions exist between code and documentation
- Changes are committed along with code changes
